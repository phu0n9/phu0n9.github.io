<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>27 - Shaders</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }

    html,
    body {
      overflow: hidden;
    }

    .webgl {
      position: fixed;
      top: 0;
      left: 0;
      outline: none;
    }
  </style>
</head>

<body>
  <canvas class="webgl"></canvas>

  <script defer src="https://ga.jspm.io/npm:es-module-shims@1.6.2/dist/es-module-shims.js"></script>


  <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.147.0/build/three.module.js",
          "lil-gui": "https://unpkg.com/lil-gui@0.16.1/dist/lil-gui.esm.js",
          "OrbitControls": "https://unpkg.com/three@0.147.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  <script type="module">
    import * as THREE from 'three'
    import { OrbitControls } from "OrbitControls"
    import * as dat from 'lil-gui'

    /**
     * Base
     */
    // Debug
    const gui = new dat.GUI()

    // Canvas
    const canvas = document.querySelector('canvas.webgl')

    // Scene
    const scene = new THREE.Scene()

    /**
     * Textures
     */
    const textureLoader = new THREE.TextureLoader()
    const flagTexture = textureLoader.load('./textures/flag-vn.jpg')

    /**
     * Test mesh
     */
    // Geometry
    const geometry = new THREE.PlaneGeometry(1, 1, 32, 32)

    const count = geometry.attributes.position.count
    const randoms = new Float32Array(count)

    for (let i = 0; i < count; i++) {
      randoms[i] = Math.random()
    }

    // a in aRandom stands for attribute
    // u for uniform
    // v for varying
    geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1))

    // Material
    const material = new THREE.ShaderMaterial({
      vertexShader: `uniform vec2 uFrequency;
    uniform float uTime;
    
    varying vec2 vUv; // = varying UV
    varying float vElevation;
    void main() {
        vec4 modelPosition = modelMatrix * vec4(position, 1.0);
    
        float elevation = sin(modelPosition.x * uFrequency.x - uTime) * 0.1;
        elevation += sin(modelPosition.y * uFrequency.y - uTime) * 0.1;
    
        modelPosition.z += elevation;
    
        vec4 viewPosition = viewMatrix * modelPosition;
        vec4 projectedPosition = projectionMatrix * viewPosition;
    
        gl_Position = projectedPosition;
    
        vUv = uv;
        vElevation = elevation;
    }`,
      fragmentShader: `uniform vec3 uColor;
    uniform sampler2D uTexture;
    
    varying vec2 vUv; // get from vertex.glsl
    varying float vElevation;
    
    void main() {
        vec4 textureColor = texture2D(uTexture, vUv); // get uv coordinates from geometry.attributes.uv
        textureColor.rgb *= vElevation * 2.0 + 0.8;
        gl_FragColor = textureColor;
    }`,
      uniforms: {
        uFrequency: { value: new THREE.Vector2(10, 5) },
        uTime: { value: 0 },
        uColor: { value: new THREE.Color('orange') },
        uTexture: { value: flagTexture }
      }
    })

    gui.add(material.uniforms.uFrequency.value, 'x')
      .min(0)
      .max(20)
      .step(0.01)
      .name('frequencyX')

    gui.add(material.uniforms.uFrequency.value, 'y')
      .min(0)
      .max(20)
      .step(0.01)
      .name('frequencyY')

    // Mesh
    const mesh = new THREE.Mesh(geometry, material)
    scene.add(mesh)

    /**
     * Sizes
     */
    const sizes = {
      width: window.innerWidth,
      height: window.innerHeight
    }

    window.addEventListener('resize', () => {
      // Update sizes
      sizes.width = window.innerWidth
      sizes.height = window.innerHeight

      // Update camera
      camera.aspect = sizes.width / sizes.height
      camera.updateProjectionMatrix()

      // Update renderer
      renderer.setSize(sizes.width, sizes.height)
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    })

    /**
     * Camera
     */
    // Base camera
    const camera = new THREE.PerspectiveCamera(75, sizes.width / sizes.height, 0.1, 100)
    camera.position.set(0.25, - 0.25, 1)
    scene.add(camera)

    // Controls
    const controls = new OrbitControls(camera, canvas)
    controls.enableDamping = true

    /**
     * Renderer
     */
    const renderer = new THREE.WebGLRenderer({
      canvas: canvas
    })
    renderer.setSize(sizes.width, sizes.height)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

    /**
     * Animate
     */
    const clock = new THREE.Clock()

    const tick = () => {
      const elapsedTime = clock.getElapsedTime()

      // Update shader materials
      material.uniforms.uTime.value = elapsedTime

      // Update controls
      controls.update()

      // Render
      renderer.render(scene, camera)

      // Call tick again on the next frame
      window.requestAnimationFrame(tick)
    }

    tick()
  </script>
</body>

</html>